// Промисы: обработка ошибок

// Цепочки промисов отлично подходят для перехвата ошибок.
// Если промис завершается с ошибкой, то управление переходит в ближайший обработчик ошибок.
// На практике это очень удобно.

// Например, в представленном ниже примере для fetch указана неправильная ссылка (сайт не существует),
// и .catch перехватывает ошибку:

// fetch("https://no-such-server.blabla") // ошибка
//     .then((response) => response.json())
//     .catch((err) => console.log(err)); // TypeError: failed to fetch (текст может отличаться)

// Как видно, .catch не обязательно должен быть сразу после ошибки,
// он может быть далее, после одного или даже нескольких .then

// Или, может быть, с сервером всё в порядке, но в ответе мы получим некорректный JSON.
// Самый лёгкий путь перехватить все ошибки – это добавить .catch в конец цепочки:

// fetch("/article/promise-chaining/user.json")
//     .then((response) => response.json())
//     .then((user) => fetch(`https://api.github.com/users/${user.name}`))
//     .then((response) => response.json())
//     .then(
//         (githubUser) =>
//             new Promise((resolve, reject) => {
//                 let img = document.createElement("img");
//                 img.src = githubUser.avatar_url;
//                 img.className = "promise-avatar-example";
//                 document.body.append(img);

//                 setTimeout(() => {
//                     img.remove();
//                     resolve(githubUser);
//                 }, 3000);
//             })
//     )
//     .catch((error) => alert(error.message));

// Если все в порядке, то такой .catch вообще не выполнится.
// Но если любой из промисов будет отклонён (проблемы с сетью или некорректная json-строка, или что угодно другое),
// то ошибка будет перехвачена.

// Необработанные ошибки

// Что произойдёт, если ошибка не будет обработана? Например,
// мы просто забыли добавить .catch в конец цепочки, как здесь:

new Promise(function () {
    noSuchFunction(); // Ошибка (нет такой функции)
}).then(() => {
    // обработчики .then, один или более
}); // без .catch в самом конце!

// В случае ошибки выполнение должно перейти к ближайшему обработчику ошибок.
// Но в примере выше нет никакого обработчика. Поэтому ошибка как бы «застревает», её некому обработать.

// На практике, как и при обычных необработанных ошибках в коде, это означает, что что-то пошло сильно не так.

// Что происходит, когда обычная ошибка не перехвачена try..catch? Скрипт умирает с сообщением в консоли.
// Похожее происходит и в случае необработанной ошибки промиса.

// JavaScript-движок отслеживает такие ситуации и генерирует в этом случае глобальную ошибку.
// Вы можете увидеть её в консоли, если запустите пример выше.

// В браузере мы можем поймать такие ошибки, используя событие unhandledrejection:

window.addEventListener("unhandledrejection", function (event) {
    // объект события имеет два специальных свойства:
    alert(event.promise); // [object Promise] - промис, который сгенерировал ошибку
    alert(event.reason); // Error: Ошибка! - объект ошибки, которая не была обработана
});

// new Promise(function () {
//     throw new Error("Ошибка!");
// }); // нет обработчика ошибок

// Если происходит ошибка, и отсутствует её обработчик, то генерируется событие unhandledrejection,
// и соответствующий объект event содержит информацию об ошибке.

// Обычно такие ошибки неустранимы, поэтому лучше всего – информировать пользователя о проблеме и,
// возможно, отправить информацию об ошибке на сервер.

//Summary
// 1).catch перехватывает все виды ошибок в промисах: будь то вызов reject() или ошибка,
// брошенная в обработчике при помощи throw.

// 2).then также перехватывает ошибки таким же образом, если задан второй аргумент
// (который является обработчиком ошибок).

// 3)Необходимо размещать .catch там, где мы хотим обработать ошибки и знаем, как это сделать.
// Обработчик может проанализировать ошибку (могут быть полезны пользовательские классы ошибок)
// и пробросить её, если ничего не знает о ней (возможно, это программная ошибка).

// 4)Можно и совсем не использовать .catch, если нет нормального способа восстановиться после ошибки.

// 5)В любом случае нам следует использовать обработчик события unhandledrejection
// (для браузеров и аналог для других окружений), чтобы отслеживать необработанные ошибки и информировать о них
// пользователя (и, возможно, наш сервер), благодаря чему наше приложение никогда не будет «просто умирать».
